# 우아한 모노리스 (2020.01.23) - 박용권

## 1. 배경

우리는 마이크로서비스에서 모노리틱으로 갈아탔다.

* Why?
  * 기술부채
  * 운영 조직과 시스템

### 1-1. 기술부채

큰 3가지 문제가 있었음

* 공유된 데이터 원본
  * 하나의 테이블을 여러 서비스가 사용하는 상황
  * 해당 테이블을 수정/조회 하는 코드가 여러군데 퍼져있다는 의미
    * 배포할때마다 챙기지 못하는 이슈가 발생 가능
* 혼잡한 기능 수행
  * 코드가 분산 되어있기 시작하면 기능의 동작이 복잡함
  * 눈으로 코드를 따라가기가 어려운 수준
    * 각 서비스가 서로 엉켜서 호출하는 경우가 빈번
  * 어떤 비지니스 요구가 왔을때 빠르게 대응하기가 어려움
* 동시 배포
  * 특정 기능을 추가하기 위해서는 **N개의 배포가 동시에** 이루어져야한다.
  * 여러 팀이 관여된다면 서로 배포 시간을 맞추는 등의 행위가 필요함

즉, **원래는 하나인데, 억지로 찢어놓으니 발생**

### 1-2. 운영조직과 시스템

* 이미 조직 규모의 몇배나 되는 서비스들로 쪼개진 상태
* 즉, 한 개발자가 동시에 여러개의 서비스를 담당하고 있었던 상황
  * 앞에 있었던 기술 부채를 가속화

## 2. 모노리틱으로 되돌아가는 여정

* 간단하게는
  * 프로젝트별 구조 정리
    * 최대한 덜 충돌나게
  * 저장소 및 프로젝트 통합
  * 패키지 구조 표준화
  * 서비스 통합
* 모노리틱은 나쁘고, 마이크로서비스는 좋다?
  * 마이크로서비스 발표에서는 넷플릭스, 아마존 등 성공 사례를 항상 언급함
    * 하지만 이 둘의 기업 규모를 생각해보면?
    * 적절한 상황이 아니면 오히려 **오버헤드만 발생**
* 모노리틱의 한계
  * 예상치 못한 결합
    * 한 곳에 코드가 다 모여있다보니 의도치 않게 코드간에 결합이 발생
  * 높은 테스트 비용
    * 결합된 코드가 많으니 자연스레 테스트하기가 점점 더 어려워짐
  * 늦은 출시 싸이클
    * 테스트하기가 어려우니 출시가 기민하게 되기가 어려움
  * 부족한 장애 내성
  * 단일 확장성
* 마이크로서비스의 장점
  * 조직 부합성
  * 확장성
  * 회복성
  * 배포용이성
  * 대체가능성
  * 기술이기종성
  * 조합성
* 마이크로서비스는 자율적이다?
  * 아키텍처 스타일을 변경하면 문제가 해결되나?
  * 큰 진흙 덩어리는 무얼하든 만날수 있다.

아키텍처를 변경하기 전에,  
**응집과 결합을 다스리는 것이 먼저다**.

> 모노리스 잘못만드는 조직은 마이크로서비스도 잘 못만들 확률이 높다.

## 3. 모듈형 모노리스 (with 스프링)

### 모듈 자율성과 컨텍스트 경계

* Spring Bean은 경계를 어떻게 나누나?
* Root Context와 Child Context를 구분한다.
* 